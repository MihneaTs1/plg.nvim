-- lua/plg/init.lua
local fn  = vim.fn
local cmd = vim.cmd
local uv  = vim.loop

local M = {}

-- 1) initial list: plg.nvim itself
M.plugins = {
  { plugin = "MihneaTs1/plg.nvim" }
}

-- normalize a user‐provided spec (string or table) into a full spec table
local function normalize_spec(spec)
  if type(spec) == "string" then
    spec = { plugin = spec }
  elseif type(spec) == "table" then
    assert(type(spec.plugin) == "string",
           "plg.nvim.use spec tables require a string `plugin` field")
    if spec.dependencies then
      for i, dep in ipairs(spec.dependencies) do
        spec.dependencies[i] = normalize_spec(dep)
      end
    end
  else
    error("plg.nvim.use received invalid spec type: " .. type(spec))
  end
  return spec
end

--- Declare a plugin (string or full spec)
-- @param spec string|"table"
function M.use(spec)
  spec = normalize_spec(spec)
  table.insert(M.plugins, spec)
end

-- internal: topo‐sort plugins + their deps
local function gather(spec, seen, out)
  local name = spec.plugin:match("^.+/(.+)$")
  if seen[name] then return end
  seen[name] = true
  if spec.dependencies then
    for _, dep in ipairs(spec.dependencies) do
      gather(dep, seen, out)
    end
  end
  table.insert(out, { spec = spec, name = name })
end

--- Install all declared plugins (with lazy/opt support, batch clone, deferred config, compiled loader)
function M.install()
  local data_dir  = fn.stdpath("data")
  local start_dir = data_dir .. "/site/pack/plg/start/"
  local opt_dir   = data_dir .. "/site/pack/plg/opt/"

  -- 1) Topo‐sort
  local seen, ordered = {}, {}
  for _, spec in ipairs(M.plugins) do
    gather(spec, seen, ordered)
  end

  -- 2) Clone missing repos (batch unpinned, individual pinned)
  local jobs, batch = {}, {}
  for _, item in ipairs(ordered) do
    local s, name = item.spec, item.name
    local target = (s.lazy and opt_dir or start_dir) .. name
    item.target = target

    if fn.empty(fn.glob(target)) > 0 then
      local url = "https://github.com/" .. s.plugin .. ".git"
      if s.version then
        local args = { "git", "clone", "--depth", "1", "--branch", s.version, url, target }
        print(("plg.nvim → cloning %s@%s"):format(s.plugin, s.version))
        jobs[#jobs+1] = fn.jobstart(args)
      else
        batch[#batch+1] = { url = url, tgt = target }
      end
    end
  end
  if #batch > 0 then
    local lines = {}
    for _, e in ipairs(batch) do
      lines[#lines+1] = e.url .. " " .. e.tgt
    end
    local list = table.concat(lines, "\n")
    local cmdline = 
      "printf '" .. list .. "' | xargs -P4 -n2 sh -c 'git clone --depth=1 \"$0\" \"$1\"'"
    print("plg.nvim → batching clone of unpinned plugins")
    jobs[#jobs+1] = fn.jobstart({ "sh", "-c", cmdline })
  end
  if #jobs > 0 then fn.jobwait(jobs, -1) end

  -- 3) packadd + config (deferred for start-plugins; lazy‐load setup for opt-plugins)
  for _, item in ipairs(ordered) do
    local s, name, tgt = item.spec, item.name, item.target
    if fn.isdirectory(tgt) == 1 then
      if not s.lazy then
        vim.defer_fn(function()
          cmd("packadd " .. name)
          if type(s.config) == "function" then pcall(s.config) end
        end, 0)
      else
        -- a) on events
        if s.event then
          local evs = type(s.event) == "table" and s.event or { s.event }
          for _, ev in ipairs(evs) do
            vim.api.nvim_create_autocmd(ev, {
              callback = function()
                cmd("packadd " .. name)
                vim.defer_fn(function()
                  if type(s.config) == "function" then pcall(s.config) end
                end, 0)
              end,
            })
          end
        end
        -- b) on commands
        if s.cmd then
          local cmds = type(s.cmd) == "table" and s.cmd or { s.cmd }
          for _, c in ipairs(cmds) do
            vim.api.nvim_create_user_command(c, function(opts)
              cmd("packadd " .. name)
              if type(s.config) == "function" then pcall(s.config) end
              vim.api.nvim_del_user_command(c)
              vim.api.nvim_exec(opts.args or "", false)
            end, { nargs = "*", bang = true })
          end
        end
        -- c) on FileType
        if s.ft then
          local fts = type(s.ft) == "table" and s.ft or { s.ft }
          vim.api.nvim_create_autocmd("FileType", {
            pattern = fts,
            callback = function()
              cmd("packadd " .. name)
              if type(s.config) == "function" then pcall(s.config) end
            end,
          })
        end
      end
    end
  end

  -- 4) generate compiled loader for next startup
  M.compile_loader(ordered)
end

--- Generate a one-shot `plugin/plg_compiled.lua` with profiling & cache
function M.compile_loader(ordered)
  local cache = fn.stdpath("cache") .. "/plg_load_times.json"
  local plugdir = fn.stdpath("data") .. "/site/pack/plg/start/plg.nvim/plugin"
  fn.mkdir(plugdir, "p")

  local lines = {
    "-- Auto-generated by plg.nvim — do not edit",
    "local uv = vim.loop",
    "local times = {}",
    "local function lp(n)",
    "  local s = uv.hrtime()",
    "  vim.cmd('packadd '..n)",
    "  local ms = (uv.hrtime()-s)/1e6",
    "  if ms>5 then print(('⚡️ %s took %.1fms'):format(n,ms)) end",
    "  times[n] = ms",
    "end",
  }
  for _, item in ipairs(ordered) do
    if not item.spec.lazy then
      lines[#lines+1] = ("lp('%s')"):format(item.name)
    end
  end
  lines[#lines+1] = ("vim.fn.writefile({vim.fn.json_encode(times)},'%s')"):format(cache)

  local f = io.open(plugdir .. "/plg_compiled.lua", "w")
  f:write(table.concat(lines, "\n"))
  f:close()
end

-- async helper: find which are behind their remotes
local function async_find_outdated(ordered, cb)
  local pending, out = #ordered, {}
  if pending == 0 then return cb(out) end

  for _, item in ipairs(ordered) do
    local tgt = fn.stdpath("data").."/site/pack/plg/start/"..item.name
    if fn.isdirectory(tgt) == 1 then
      local cmdstr = 
        "git -C "..tgt.." fetch --quiet && git -C "..tgt.." rev-list --count HEAD..@{u}"
      fn.jobstart(cmdstr, {
        stdout_buffered = true,
        on_stdout = function(_,d)
          if tonumber(d[1]) and tonumber(d[1])>0 then
            out[#out+1] = item
          end
        end,
        on_exit = function()
          pending = pending - 1
          if pending == 0 then cb(out) end
        end,
      })
    else
      pending = pending - 1
      if pending == 0 then cb(out) end
    end
  end
end

--- Update only the outdated (skip pinned), async so UI never blocks
function M.update()
  local seen, ordered = {}, {}
  for _, s in ipairs(M.plugins) do gather(s, seen, ordered) end

  async_find_outdated(ordered, function(out)
    if #out == 0 then
      print("plg.nvim → all plugins up-to-date")
      return
    end
    local jobs = {}
    for _, item in ipairs(out) do
      local s, name = item.spec, item.name
      local tgt = fn.stdpath("data").."/site/pack/plg/start/"..name
      if s.version then
        print(("plg.nvim → pinned %s@%s → skipping update")
              :format(s.plugin, s.version))
      else
        print("plg.nvim → updating "..s.plugin)
        jobs[#jobs+1] = fn.jobstart({ "git", "-C", tgt, "pull", "--ff-only" })
      end
    end
    if #jobs > 0 then fn.jobwait(jobs, -1); print("plg.nvim → updates complete") end
  end)
end

return M
